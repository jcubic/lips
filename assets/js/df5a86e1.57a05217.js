"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[5011],{5558:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scheme-intro/continuations","title":"Continuations","description":"Powerful feature of Scheme that allow to add new control flows","source":"@site/docs/scheme-intro/continuations.md","sourceDirName":"scheme-intro","slug":"/scheme-intro/continuations","permalink":"/docs/scheme-intro/continuations","draft":false,"unlisted":false,"editUrl":"https://github.com/jcubic/lips/tree/master/docs/docs/scheme-intro/continuations.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"description":"Powerful feature of Scheme that allow to add new control flows"},"sidebar":"tutorialSidebar","previous":{"title":"Streams","permalink":"/docs/scheme-intro/streams"},"next":{"title":"What Next?","permalink":"/docs/scheme-intro/next-step"}}');var a=t(4848),o=t(8453);const c={sidebar_position:7,description:"Powerful feature of Scheme that allow to add new control flows"},s="Continuations",r={},l=[{value:"What is continuation?",id:"what-is-continuation",level:2},{value:"Accessing current continuation",id:"accessing-current-continuation",level:2},{value:"Calling continuations",id:"calling-continuations",level:2},{value:"Early exit",id:"early-exit",level:2},{value:"Loops",id:"loops",level:2},{value:"Generators",id:"generators",level:2},{value:"Generator macro",id:"generator-macro",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"continuations",children:"Continuations"})}),"\n",(0,a.jsx)(n.h2,{id:"what-is-continuation",children:"What is continuation?"}),"\n",(0,a.jsx)(n.p,{children:"In Scheme a continuation is a thing that is waiting for an expression to be evaluated. When you have\nan expression the arguments are evaluated first, so the function application is waiting for the\narguments to get evaluated before the function can be applied."}),"\n",(0,a.jsx)(n.p,{children:"If you have code like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(+ 1 2 <slot>)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["and ",(0,a.jsx)(n.code,{children:"<slot>"})," is an expression: (e.g.: ",(0,a.jsx)(n.code,{children:"(/ 1 10)"}),")"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(+ 1 2 (/ 1 10))\n;; ==> 31/10\n"})}),"\n",(0,a.jsxs)(n.p,{children:["then continuation for expression ",(0,a.jsx)(n.code,{children:"(/ 1 10)"})," is ",(0,a.jsx)(n.code,{children:"(+ 1 2 <slot>)"}),". Continuations is the next\nexpression that needs to be evaluated."]}),"\n",(0,a.jsx)(n.p,{children:"Scheme is unique because it allows accessing continuations. They are first class objects like\nnumbers or functions."}),"\n",(0,a.jsx)(n.p,{children:"You can be represented continuation as a function:"}),"\n",(0,a.jsxs)(n.p,{children:["if ",(0,a.jsx)(n.code,{children:"(/ 1 10)"})," is ",(0,a.jsx)(n.code,{children:"z"})," the contunuation of the whole expression can be represented as a function,\nthat may look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(lambda (z)\n  (+ 1 2 z))\n"})}),"\n",(0,a.jsx)(n.h2,{id:"accessing-current-continuation",children:"Accessing current continuation"}),"\n",(0,a.jsxs)(n.p,{children:["To access the current continuation for an expression, you need to use ",(0,a.jsx)(n.code,{children:"call-with-current-continuation"}),"\nor its abbreviation ",(0,a.jsx)(n.code,{children:"call/cc"}),". The procedure ",(0,a.jsx)(n.code,{children:"call/cc"})," accepts a single procedure that get the\ncontinuation as first argument:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(call/cc (lambda (cc)\n           ...))\n"})}),"\n",(0,a.jsx)(n.p,{children:"So to capute the continuation expressed as a function you can use code like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(+ 1 2 (call/cc\n        (lambda (c)\n          (/ 1 10))))\n;; ==> 31/10\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The continuation saved in ",(0,a.jsx)(n.code,{children:"c"})," capture whole state of the Scheme interpreter. The continuation act as\na procedure that you can pass a single value to it and Scheme will jump in to the place where\ncontinuation was captured with a given value."]}),"\n",(0,a.jsx)(n.h2,{id:"calling-continuations",children:"Calling continuations"}),"\n",(0,a.jsx)(n.p,{children:"You can save continuation inside a variable and call it later like a procedure."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define k #f)\n\n(display (+ 1 2 (call/cc\n                 (lambda (continuation)\n                   (set! k continuation)\n                   (/ 1 10)))))\n;; ==> 31/10\n(k 3)\n;; ==> 6\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here when you call a continuation ",(0,a.jsx)(n.code,{children:"k"})," with value 6 it restores the state in ",(0,a.jsx)(n.code,{children:"(+ 1 2 <slot>)"})," and\nexecute that expression again with a value ",(0,a.jsx)(n.code,{children:"3"})," (expression ",(0,a.jsx)(n.code,{children:"(+ 1 2 3)"}),")."]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["Note that the above code will create an infinite loop when called inside an expression like ",(0,a.jsx)(n.code,{children:"let"}),":"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(let ()\n  (define k #f)\n  (display (+ 1 2 (call/cc\n                   (lambda (continuation)\n                     (set! k continuation)\n                     (/ 1 10)))))\n\n  (newline)\n  (k 3)) ;; start infinite loop\n"})}),(0,a.jsx)(n.p,{children:"Above code will print 6 in an ifnite loop, because the continuation don't end at display, like in\nprevious example, only continue executing newline and next call to the continuation."})]}),"\n",(0,a.jsxs)(n.p,{children:["The continuation act like a procedure and return ",(0,a.jsx)(n.code,{children:"#t"})," with a ",(0,a.jsx)(n.code,{children:"procedure?"})," predicate:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define k (call/cc (lambda (c) c)))\n(procedure? k)\n;; ==> #t\n"})}),"\n",(0,a.jsx)(n.h2,{id:"early-exit",children:"Early exit"}),"\n",(0,a.jsxs)(n.p,{children:["The simple thing you can do with continuations is an early exit. Scheme doesn't have a ",(0,a.jsx)(n.code,{children:"return"}),"\nexpression, but with continuations you can add one."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (find item lst)\n  (call/cc (lambda (return)\n             (let loop ((lst lst))\n                (if (null? lst)\n                    (return #f)\n                    (if (equal? item (car lst))\n                        (return lst)\n                        (loop (cdr lst))))))))\n"})}),"\n",(0,a.jsx)(n.p,{children:"Above function is recursive function but the continuations saved before the loop and when calling\nreturn it immedielty jump to the beginning with a given value."}),"\n",(0,a.jsxs)(n.p,{children:["You can even create abstraction of ",(0,a.jsx)(n.code,{children:"return"})," with an ",(0,a.jsx)(n.a,{href:"/docs/scheme-intro/macros#anaphoric-macros",children:"anaphoric\nmacro"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define-macro (alambda args . body)\n  `(lambda ,args\n     (call/cc (lambda (return)\n                ,@body))))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["and you can use this macro like normal a ",(0,a.jsx)(n.code,{children:"lambda"}),", but you have anaphoric ",(0,a.jsx)(n.code,{children:"return"})," expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define exists? (alambda (item lst)\n                         (for-each (lambda (x)\n                                     (if (equal? x item)\n                                         (return #t)))\n                                   lst)\n                         #f))\n\n(exists? 'x '(a b c d e f))\n;; ==> #f\n(exists? 'd '(a b c d e f))\n;; ==> #t\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here ",(0,a.jsx)(n.code,{children:"for-each"})," always iterates over all elements, but with continuation, it will return immediately when\na value is found."]}),"\n",(0,a.jsx)(n.h2,{id:"loops",children:"Loops"}),"\n",(0,a.jsx)(n.p,{children:"You can create loops with continuations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (make-range from to)\n  (call/cc\n   (lambda (return)\n     (let ((result '()))\n       (let ((loop (call/cc (lambda (k) k))))\n         (if (<= from to)\n             (set! result (cons from result))\n             (return (reverse result)))\n         (set! from (+ from 1))\n         (loop loop))))))\n\n(make-range 1 10)\n;; ==> (1 2 3 4 5 6 7 8 9 10)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The first continuation creates an early exit, like in the previous example. But the second ",(0,a.jsx)(n.code,{children:"call/cc"})," use\nidentity function (it returns continuation). Which means that the continuation is saved in a loop\nvariable. And each time it's called with ",(0,a.jsx)(n.code,{children:"loop"})," as an argument, it's again assigned that\ncontinuation to loop variable. This is required for the next loop."]}),"\n",(0,a.jsx)(n.h2,{id:"generators",children:"Generators"}),"\n",(0,a.jsxs)(n.p,{children:["Some languages have generators and a ",(0,a.jsx)(n.code,{children:"yield"})," keyword. In Scheme, you can create generators with\ncontinuations."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define (make-coroutine-generator proc)\n  (define void (if #f #f))\n  (define return #f)\n  (define resume #f)\n  (define yield (lambda (v)\n                  (call/cc (lambda (r)\n                             (set! resume r)\n                             (return v)))))\n  (lambda ()\n    (call/cc (lambda (cc)\n               (set! return cc)\n               (if resume\n                   (resume void)  ; void? or yield again?\n                   (begin (proc yield)\n                          (set! resume (lambda (v)\n                                         (return (eof-object))))\n                          (return (eof-object))))))))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The above example came from\n",(0,a.jsx)(n.a,{href:"https://github.com/scheme-requests-for-implementation/srfi-158/blob/master/srfi-158-impl.scm#L77-L87",children:"SRFI 158 example implementation"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["There are two saved continuations that interact with each other. First is return like in one the\nprevious examples. And the other is ",(0,a.jsx)(n.code,{children:"yield"})," that saves the point when it was called and return the\nvalue. When the main function is called (the return ",(0,a.jsx)(n.code,{children:"lambda"}),") for the first time it saves the return\nfrom the function for the ",(0,a.jsx)(n.code,{children:"yield"})," and execute the main function with ",(0,a.jsx)(n.code,{children:"yield"})," as argument. But when\nyou execute the function next time, it call resume, the location when ",(0,a.jsx)(n.code,{children:"yield"})," was called. When yield\nis not called it return ",(0,a.jsx)(n.code,{children:"eof-object"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The procedure ",(0,a.jsx)(n.code,{children:"make-coroutine-generator"})," allows defining generators:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:"(define counter (make-coroutine-generator\n                 (lambda (yield)\n                   (do ((i 0 (+ i 1)))\n                     ((<= 3 i))\n                     (yield i)))))\n\n(counter) ;; ==> 0\n(counter) ;; ==> 1\n(counter) ;; ==> 2\n(counter) ;; ==> #<eof>\n"})}),"\n",(0,a.jsx)(n.p,{children:"With continuations, you can do a lot of cool new flow control structures."}),"\n",(0,a.jsx)(n.h2,{id:"generator-macro",children:"Generator macro"}),"\n",(0,a.jsxs)(n.p,{children:["With help from macros and\n",(0,a.jsx)(n.a,{href:"https://srfi.schemers.org/srfi-139/srfi-139.html",children:"SRFI-139"})," described in section about ",(0,a.jsx)(n.a,{href:"/docs/scheme-intro/macros#anaphoric-hygienic-macros",children:"Anaphoric Hygienic Macros"})," you can create an abstraction over generators:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scheme",children:'(define-syntax-parameter yield\n  (syntax-rules ()\n    ((_)\n     (syntax-error "Use outside lambda*"))))\n\n(define-syntax lambda*\n  (syntax-rules ()\n    ((_ args body ...)\n     (lambda args\n       (make-coroutine-generator\n        (lambda (cc)\n          (syntax-parameterize\n           ((yield (syntax-rules ()\n                     ((_ x) (cc x))\n                     ((_) (cc)))))\n           body ...)))))))\n\n(define gen (lambda* (start end)\n              (do ((i start (+ i 1)))\n                ((> i end))\n                (yield i))))\n\n(define (generator->list gen)\n  (let loop ((item (gen))\n             (result \'()))\n    (if (eof-object? item)\n        (reverse result)\n        (loop (gen) (cons item result)))))\n\n(let ((counter (gen 1 10)))\n  (display (generator->list counter))\n  (newline))\n;; ==> (1 2 3 4 5 6 7 8 9 10)\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"lambda*"})," works similar to\n",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",children:"JavaScript generators"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function* gen(start, end) {\n    for (let i = start; i <= end; ++i) {\n        yield i;\n    }\n}\n\nArray.from(gen(1, 10));\n// ==> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);