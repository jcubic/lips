"use strict";(self.webpackChunknew_docs=self.webpackChunknew_docs||[]).push([[1033],{4988:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var a=i(6286),t=i(4848),r=i(8453);const s={slug:"serialization",title:"How to serialize any object in JavaScript?",authors:"jcubic",image:"/img/serialization.png",tags:["javascript","internals"]},o=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Serialization with JSON",id:"serialization-with-json",level:2},{value:"Serialization with compressed CBOR",id:"serialization-with-compressed-cbor",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this article, I will explain how the serialization of objects (in dump compiler) works in LIPS."}),"\n",(0,t.jsx)(n.p,{children:"As a way of optimization, I decided to save the representation of the parsed code as a file."}),"\n",(0,t.jsx)(n.p,{children:"The input Scheme code was read, parsed, and the tree structure was then serialized. The code had\nobjects, like a Pair, that needed to be saved and restored to and from a file."}),"\n",(0,t.jsx)(n.p,{children:"The compiler in LIPS, is the same code that evaluate the code, it only returns different results, the\ncode instead of a value. So if there are any side effects, they will happen during compilation.\nThat's why it's a dump compiler, where the output code is serialized into a file, that can then later\nbe unserialized."}),"\n",(0,t.jsx)(n.h2,{id:"serialization-with-json",children:"Serialization with JSON"}),"\n",(0,t.jsx)(n.p,{children:"The first approach, to serialize the data, was to use JSON and take the benefit of the second\nargument in JSON.stringify and JSON.parse."}),"\n",(0,t.jsxs)(n.p,{children:["Each object was saved as ",(0,t.jsx)(n.code,{children:'{"@": "class", "#": data}'}),"."]}),"\n",(0,t.jsx)(n.p,{children:"So the Pair class was saved as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{"@": "Pair", "#": [car, cdr]}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Later, the class field was change into an index to make the output JSON file smaller."}),"\n",(0,t.jsx)(n.p,{children:"The code responsible for serialization is still part of the project, so LIPS can still open old files. It looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function serialize(data) {\n    return JSON.stringify(data, function(key, value) {\n        const v0 = this[key];\n        if (v0) {\n            if (v0 instanceof RegExp) {\n                return {\n                    '@': mangle_name('regex'),\n                    '#': [v0.source, v0.flags]\n                };\n            }\n            var cls = mangle_name(v0.constructor.__class__);\n            if (!is_undef(cls)) {\n                return {\n                    '@': cls,\n                    '#': v0.serialize()\n                };\n            }\n        }\n        return value;\n    });\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see from the code, it can serialize the regular expressions and internal classes by calling a serialize method."}),"\n",(0,t.jsx)(n.p,{children:"Here is example serialize method for class Pair:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Pair.prototype.serialize = function() {\n    return [\n        this.car,\n        this.cdr\n    ];\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Function ",(0,t.jsx)(n.code,{children:"mangle_name"})," was also an optimization that make the classes smaller. Each class had an\nindex where Pair had index ",(0,t.jsx)(n.code,{children:"0"})," saved in ",(0,t.jsx)(n.code,{children:"serialization_map"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var serialization_map = {\n    'pair': ([car, cdr]) => Pair(car, cdr),\n    'number': function(value) {\n        if (LString.isString(value)) {\n            return LNumber([value, 10]);\n        }\n        return LNumber(value);\n    },\n    'regex': function([pattern, flag]) {\n        return new RegExp(pattern, flag);\n    },\n    'nil': function() {\n        return nil;\n    },\n    'symbol': function(value) {\n        if (LString.isString(value)) {\n            return LSymbol(value);\n        } else if (Array.isArray(value)) {\n            return LSymbol(Symbol.for(value[0]));\n        }\n    },\n    'string': LString,\n    'character': LCharacter\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"A serialization map was also used to unserialized the data from the JSON. Here is how the function look like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function unserialize(string) {\n    return JSON.parse(string, (_, object) => {\n        if (object && typeof object === 'object') {\n            if (!is_undef(object['@'])) {\n                var cls = resolve_name(object['@']);\n                if (serialization_map[cls]) {\n                    return serialization_map[cls](object['#']);\n                }\n            }\n        }\n        return object;\n    });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Function ",(0,t.jsx)(n.code,{children:"resolve_name"})," is reverse of ",(0,t.jsx)(n.code,{children:"mangle_name"})," which return class name based on index."]}),"\n",(0,t.jsx)(n.h2,{id:"serialization-with-compressed-cbor",children:"Serialization with compressed CBOR"}),"\n",(0,t.jsxs)(n.p,{children:["But the output of JSON file was big, so I decided to create a better serialization. This is when I\nfound about ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/CBOR",children:"CBOR binary data format"}),". I found a fast library\n",(0,t.jsx)(n.a,{href:"https://github.com/kriszyp/cbor-x",children:"cbor-x"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The library has an API that allow adding custom extensions to add any type of objects."}),"\n",(0,t.jsx)(n.p,{children:"This the function that add support for all internal data types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const cbor = (function() {\n\n    var types = {\n        'pair': Pair,\n        'symbol': LSymbol,\n        'number': LNumber,\n        'string': LString,\n        'character': LCharacter,\n        'nil': nil.constructor,\n        'regex': RegExp\n    };\n\n    function serializer(Class, fn) {\n        return {\n            deserialize: fn,\n            Class\n        };\n    }\n\n    var encoder = new Encoder();\n\n    const cbor_serialization_map = {};\n    for (const [ name, fn ] of Object.entries(serialization_map)) {\n        const Class = types[name];\n        cbor_serialization_map[name] = serializer(Class, fn);\n    }\n    // add CBOR data mapping\n    let tag = 43311;\n    Object.keys(cbor_serialization_map).forEach(type => {\n        const data = cbor_serialization_map[type];\n        if (typeof data === 'function') {\n            const Class = data;\n            addExtension({\n                Class,\n                tag,\n                encode(instance, encode) {\n                    encode(instance.serialize());\n                },\n                decode(data) {\n                    return new Class(data);\n                }\n            });\n        } else {\n            const { deserialize, Class } = data;\n            addExtension({\n                Class,\n                tag,\n                encode(instance, encode) {\n                    if (instance instanceof RegExp) {\n                        return encode([instance.source, instance.flags]);\n                    }\n                    encode(instance.serialize());\n                },\n                decode(data) {\n                    return deserialize(data);\n                }\n            });\n        }\n        tag++;\n    });\n    return encoder;\n})();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["After this, you only need to use the ",(0,t.jsx)(n.code,{children:"cbor.encode"})," to serialize the data and ",(0,t.jsx)(n.code,{children:"cbor.decode"})," to unserialize."]}),"\n",(0,t.jsx)(n.p,{children:"But the CBOR output data was still big, it could be compressed (I could also do the same with JSON files)."}),"\n",(0,t.jsxs)(n.p,{children:["I was searching for good and fast compression library and found implementation of\n",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Jeff_Bonwick#LZJB",children:"LZJB"})," and a library ",(0,t.jsx)(n.a,{href:"https://github.com/copy/jslzjb-k",children:"lzjb-k"}),"\non GitHub. I converted it into a module and published to NPM as ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/lzjb-pack",children:"lzjb-pack"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"To create a binary file I compressed the output CBOR data and add a magic number in front."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { addExtension, Encoder } from 'cbor-x';\n\nfunction encode_magic() {\n    const VERSION = 1;\n    const encoder = new TextEncoder('utf-8');\n    return encoder.encode(`LIPS${VERSION.toString().padStart(3, ' ')}`);\n}\n\nconst MAGIC_LENGTH = 7;\n\nfunction decode_magic(obj) {\n    const decoder = new TextDecoder('utf-8');\n    const prefix = decoder.decode(obj.slice(0, MAGIC_LENGTH));\n    const name = prefix.substring(0, 4);\n    if (name === 'LIPS') {\n        const m = prefix.match(/^(....).*([0-9]+)$/);\n        if (m) {\n            return {\n                type: m[1],\n                version: Number(m[2])\n            };\n        }\n    }\n    return {\n        type: 'unknown'\n    };\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will make it easier for the future to read multiple version of the binary data."}),"\n",(0,t.jsx)(n.p,{children:"The serialization and deserialization functions look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { pack, unpack } from 'lzjb-pack';\n\nfunction serialize_bin(obj) {\n    const magic = encode_magic();\n    const payload = cbor.encode(obj);\n    return merge_uint8_array(magic, pack(payload, { magic: false }));\n}\n\nfunction unserialize_bin(data) {\n    const { type, version } = decode_magic(data);\n    if (type === 'LIPS' && version === 1) {\n        const arr = unpack(data.slice(MAGIC_LENGTH), { magic: false });\n        return cbor.decode(arr);\n    } else {\n        throw new Error(`Invalid file format ${type}`);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"And this is the whole serialization, done by LIPS."}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The compressed CBOR file is way smaller than the source code and way smaller than JSON file,\nthat is way bigger then the input file. But the JSON can still be compressed which was not tested."}),"\n",(0,t.jsx)(n.p,{children:"This is summary of the size of the standard library serialized in this way:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"File Comparison"}),(0,t.jsx)(n.th,{children:"Size"}),(0,t.jsx)(n.th,{children:"Size Difference"}),(0,t.jsx)(n.th,{children:"Percentage Change"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"std.scm"}),(0,t.jsx)(n.td,{children:"207k"}),(0,t.jsx)(n.td,{children:"-"}),(0,t.jsx)(n.td,{children:"-"}),(0,t.jsx)(n.td,{children:"source code"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"std.xcm"}),(0,t.jsx)(n.td,{children:"478K"}),(0,t.jsx)(n.td,{children:"+271k"}),(0,t.jsx)(n.td,{children:"+130.92%"}),(0,t.jsx)(n.td,{children:"JSON"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"std.xcb"}),(0,t.jsx)(n.td,{children:"105K"}),(0,t.jsx)(n.td,{children:"-102k"}),(0,t.jsx)(n.td,{children:"-49.28%"}),(0,t.jsx)(n.td,{children:"CBOR+LZJB"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var a=i(6540);const t={},r=a.createContext(t);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},6286:e=>{e.exports=JSON.parse('{"permalink":"/blog/serialization","editUrl":"https://github.com/jcubic/lips/tree/master/docs/blog/2025-09-14-object-serialization.md","source":"@site/blog/2025-09-14-object-serialization.md","title":"How to serialize any object in JavaScript?","description":"In this article, I will explain how the serialization of objects (in dump compiler) works in LIPS.","date":"2025-09-14T00:00:00.000Z","tags":[{"inline":true,"label":"javascript","permalink":"/blog/tags/javascript"},{"inline":true,"label":"internals","permalink":"/blog/tags/internals"}],"readingTime":5.18,"hasTruncateMarker":true,"authors":[{"name":"Jakub T. Jankiewicz","title":"LIPS maintainer","url":"https://jakub.jankiewicz.org/","imageURL":"https://github.com/jcubic.png","key":"jcubic","page":null}],"frontMatter":{"slug":"serialization","title":"How to serialize any object in JavaScript?","authors":"jcubic","image":"/img/serialization.png","tags":["javascript","internals"]},"unlisted":false,"nextItem":{"title":"Internals: Syntax Extensions","permalink":"/blog/syntax-extensions"}}')}}]);